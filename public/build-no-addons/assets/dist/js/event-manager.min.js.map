{"version":3,"file":"js/event-manager.min.js","mappings":"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","sources":["webpack:///./js/utils/event-manager.js"],"sourcesContent":["/**\n * Event Manager Utility\n * \n * Este módulo fornece um sistema de gerenciamento de eventos baseado em classes\n * que permite rotear eventos para manipuladores específicos com base nas classes\n * dos elementos que disparam os eventos.\n * \n * @module EventManager\n * @version 1.0.0\n */\n\n/**\n * Classe que gerencia o roteamento de eventos baseado em classes CSS\n */\nclass EventManager {\n  /**\n   * Cria uma nova instância do gerenciador de eventos\n   */\n  constructor() {\n    // Mapa de componentes registrados\n    this.components = new Map();\n    \n    // Mapa de classes para componentes\n    this.classHandlers = new Map();\n    \n    // Estado de inicialização\n    this.initialized = false;\n    \n    // Timestamp do último evento processado\n    this.lastEvent = null;\n    \n    // Bind dos métodos\n    this.handleEvent = this.handleEvent.bind(this);\n    \n    // Inicializa quando o DOM estiver pronto\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => this.init());\n    } else {\n      this.init();\n    }\n  }\n  \n  /**\n   * Inicializa o gerenciador de eventos\n   */\n  init() {\n    if (this.initialized) return;\n    \n    console.log('[EventManager] Inicializando gerenciador de eventos baseado em classes');\n    \n    // Configura os listeners de eventos\n    this.setupEventListeners();\n    \n    this.initialized = true;\n  }\n  \n  /**\n   * Configura os listeners de eventos\n   */\n  setupEventListeners() {\n    // Usa captura para garantir que pegamos o evento primeiro\n    document.addEventListener('click', this.handleEvent, true);\n    document.addEventListener('keydown', this.handleEvent, true);\n    document.addEventListener('focusin', this.handleEvent, true);\n    \n    console.log('[EventManager] Listeners de eventos configurados');\n  }\n  \n  /**\n   * Registra um componente para receber eventos\n   * @param {string} componentName - Nome do componente (ex: 'menu', 'shortcuts')\n   * @param {Object} config - Configuração do componente\n   * @param {HTMLElement} config.element - Elemento raiz do componente\n   * @param {Function} config.handler - Função que processa os eventos\n   * @param {Array<string>} config.classes - Classes dos elementos que disparam eventos\n   * @returns {boolean} - True se o componente foi registrado com sucesso\n   */\n  registerComponent(componentName, { element, handler, classes = [] }) {\n    console.group(`[EventManager] Registrando componente: ${componentName}`);\n    \n    if (!element || !handler) {\n      console.error(`[EventManager] Componente ${componentName} inválido: elemento ou handler não fornecido`);\n      console.groupEnd();\n      return false;\n    }\n    \n    console.log('[EventManager] Elemento do componente:', element);\n    console.log('[EventManager] Classes fornecidas:', classes);\n    \n    // Armazena o componente\n    this.components.set(componentName, {\n      element,\n      handler,\n      enabled: true,\n      classes: new Set(classes)\n    });\n    \n    // Registra as classes de origem dos eventos\n    classes.forEach(className => {\n      if (!this.classHandlers.has(className)) {\n        this.classHandlers.set(className, new Set());\n      }\n      this.classHandlers.get(className).add(componentName);\n      console.log(`[EventManager] Classe registrada: .${className} para ${componentName}`);\n    });\n    \n    console.log(`[EventManager] Componente ${componentName} registrado com sucesso`);\n    console.log('[EventManager] Componentes registrados:', Array.from(this.components.keys()));\n    console.log('[EventManager] Classes registradas:', Array.from(this.classHandlers.keys()));\n    console.groupEnd();\n    \n    return true;\n  }\n  \n  /**\n   * Manipulador principal de eventos\n   * @param {Event} event - O evento a ser processado\n   */\n  handleEvent(event) {\n    console.group(`[EventManager] handleEvent - ${event.type}`);\n    console.log('Evento recebido:', event.type, 'em', event.target);\n    \n    // Verifica se o evento já foi tratado\n    if (event._eventManagerProcessed) {\n      console.log('[EventManager] Evento já processado, ignorando...');\n      console.groupEnd();\n      return;\n    }\n    \n    // Evita processar eventos muito rapidamente\n    if (this.lastEvent && event.timeStamp - this.lastEvent < 10) {\n      console.log('[EventManager] Evento muito rápido, ignorando...');\n      console.groupEnd();\n      return;\n    }\n    this.lastEvent = event.timeStamp;\n    \n    // Encontra os componentes que devem processar este evento\n    const componentsToProcess = this.findComponentsForEvent(event);\n    \n    if (componentsToProcess.size > 0) {\n      console.log('[EventManager] Componentes para processar:', Array.from(componentsToProcess).join(', '));\n      \n      // Se encontrou componentes para processar o evento, previne a propagação\n      // apenas se não for um clique em um item de menu ou em um de seus filhos diretos\n      const isMenuTarget = this.closestElement(event.target, '.menu-item-has-children > a, .page_item_has_children > a, .submenu-toggle');\n      if (!isMenuTarget) {\n        // Para eventos que não são em itens de menu, prevenimos a propagação\n        // para evitar que outros manipuladores interfiram\n        event.stopPropagation();\n      } else {\n        console.log('[EventManager] Clique em item de menu, permitindo propagação controlada');\n        // Para itens de menu, prevenimos o comportamento padrão apenas\n        // para evitar navegação indesejada\n        event.preventDefault();\n      }\n      \n      // Marca o evento como processado\n      event._eventManagerProcessed = true;\n      \n      // Chama os manipuladores dos componentes\n      componentsToProcess.forEach(componentName => {\n        const component = this.components.get(componentName);\n        if (component && component.enabled && component.handler) {\n          try {\n            component.handler(event, component);\n          } catch (error) {\n            console.error(`[EventManager] Erro no manipulador do componente ${componentName}:`, error);\n          }\n        }\n      });\n    } else {\n      console.log('[EventManager] Nenhum componente encontrado para processar o evento');\n    }\n    \n    console.groupEnd();\n  }\n  \n  /**\n   * Encontra os componentes que devem processar um evento com base nas classes do elemento alvo\n   * @param {Event} event - O evento a ser processado\n   * @returns {Set<string>} Conjunto de nomes de componentes que devem processar o evento\n   */\n  findComponentsForEvent(event) {\n    const components = new Set();\n    let element = event.target;\n    \n    console.group('[EventManager] findComponentsForEvent');\n    console.log('[EventManager] Procurando manipuladores para o elemento:', element);\n    console.log('[EventManager] Classes do elemento:', element.className);\n    \n    // Verifica se o clique foi em um item de menu ou em um de seus filhos\n    const menuItem = this.closestElement(element, '.menu-item, .menu-item-has-children, .page_item_has_children, .submenu-toggle, .menu-item-has-children > a, .page_item_has_children > a');\n    \n    if (menuItem) {\n      console.log('[EventManager] Clique em item de menu ou filho, verificando manipuladores...');\n      console.log('[EventManager] Tag do elemento:', menuItem.tagName);\n      console.log('[EventManager] Classes do item de menu:', menuItem.className);\n      \n      // Adiciona as classes do item de menu à verificação\n      if (menuItem.classList && menuItem.classList.length > 0) {\n        console.log('[EventManager] Verificando classes do item de menu:', Array.from(menuItem.classList).join(', '));\n        \n        menuItem.classList.forEach(className => {\n          if (this.classHandlers.has(className)) {\n            console.log(`[EventManager] Encontrada classe registrada: ${className}`);\n            this.classHandlers.get(className).forEach(componentName => {\n              components.add(componentName);\n              console.log(`[EventManager] Adicionando componente: ${componentName}`);\n            });\n          }\n        });\n      } else {\n        console.log('[EventManager] Item de menu sem classes');\n      }\n    }\n    \n    // Se não encontrou componentes ainda, verifica o elemento clicado e seus ancestrais\n    if (components.size === 0) {\n      console.log('[EventManager] Nenhum manipulador encontrado, verificando ancestrais...');\n      \n      while (element && element !== document.documentElement) {\n        if (element.classList && element.classList.length > 0) {\n          console.log(`[EventManager] Verificando elemento:`, element);\n          console.log(`[EventManager] Classes:`, Array.from(element.classList).join(', '));\n          \n          element.classList.forEach(className => {\n            if (this.classHandlers.has(className)) {\n              console.log(`[EventManager] Encontrada classe registrada: ${className}`);\n              this.classHandlers.get(className).forEach(componentName => {\n                components.add(componentName);\n                console.log(`[EventManager] Adicionando componente: ${componentName}`);\n              });\n            }\n          });\n          \n          // Se encontrou algum componente, para a busca\n          if (components.size > 0) {\n            console.log(`[EventManager] Encontrados ${components.size} componentes para o evento`);\n            break;\n          }\n        }\n        \n        // Vai para o elemento pai\n        element = element.parentElement;\n      }\n    } else {\n      console.log(`[EventManager] Encontrados ${components.size} componentes no item de menu`);\n    }\n    \n    console.log('[EventManager] Componentes que vão processar o evento:', Array.from(components).join(', '));\n    console.groupEnd();\n    \n    return components;\n  }\n  \n  /**\n   * Encontra o elemento ancestral mais próximo que corresponde ao seletor\n   * @param {HTMLElement} element - Elemento inicial\n   * @param {string} selector - Seletor CSS\n   * @returns {HTMLElement|null} - Elemento correspondente ou null\n   */\n  closestElement(element, selector) {\n    if (!element || !selector) return null;\n    \n    // Usa o método nativo se disponível\n    if (element.closest) {\n      return element.closest(selector);\n    }\n    \n    // Implementação alternativa para navegadores mais antigos\n    while (element) {\n      if (this.matchesSelector(element, selector)) {\n        return element;\n      }\n      element = element.parentElement;\n    }\n    return null;\n  }\n  \n  /**\n   * Verifica se o elemento corresponde ao seletor\n   * @param {HTMLElement} element - Elemento a ser verificado\n   * @param {string} selector - Seletor CSS\n   * @returns {boolean} - True se o elemento corresponder ao seletor\n   */\n  matchesSelector(element, selector) {\n    const matches = element.matches || \n                   element.matchesSelector || \n                   element.webkitMatchesSelector || \n                   element.mozMatchesSelector ||\n                   element.msMatchesSelector ||\n                   element.oMatchesSelector;\n    \n    if (matches) {\n      return matches.call(element, selector);\n    }\n    \n    // Implementação alternativa para navegadores antigos\n    const matchesList = (element.document || element.ownerDocument).querySelectorAll(selector);\n    let i = matchesList.length;\n    \n    while (--i >= 0 && matchesList.item(i) !== element) {}\n    return i > -1;\n  }\n  \n  /**\n   * Habilita/desabilita um componente\n   * @param {string} componentName - Nome do componente\n   * @param {boolean} enabled - Se true, habilita o componente; se false, desabilita\n   * @returns {boolean} - True se o componente foi encontrado e atualizado\n   */\n  setComponentEnabled(componentName, enabled = true) {\n    const component = this.components.get(componentName);\n    if (component) {\n      component.enabled = enabled;\n      console.log(`[EventManager] Componente ${componentName} ${enabled ? 'habilitado' : 'desabilitado'}`);\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Remove todos os event listeners e limpa recursos\n   */\n  destroy() {\n    // Remove os event listeners\n    document.removeEventListener('click', this.handleEvent, true);\n    document.removeEventListener('keydown', this.handleEvent, true);\n    document.removeEventListener('focusin', this.handleEvent, true);\n    \n    // Limpa as estruturas de dados\n    this.components.clear();\n    this.classHandlers.clear();\n    \n    // Reseta o estado\n    this.initialized = false;\n    this.lastEvent = null;\n    \n    console.log('[EventManager] Gerenciador de eventos desativado');\n  }\n}\n\n// Cria uma instância global do gerenciador de eventos\nconst eventManager = new EventManager();\n\n// Exporta a instância como padrão e a classe como exportação nomeada\nexport { EventManager };\nexport default eventManager;\n"],"names":["constructor","this","components","Map","classHandlers","initialized","lastEvent","handleEvent","bind","document","readyState","addEventListener","init","console","log","setupEventListeners","registerComponent","componentName","element","handler","classes","group","set","enabled","Set","forEach","className","has","get","add","Array","from","keys","groupEnd","error","event","type","target","_eventManagerProcessed","timeStamp","componentsToProcess","findComponentsForEvent","size","join","closestElement","preventDefault","stopPropagation","component","menuItem","tagName","classList","length","documentElement","parentElement","selector","closest","matchesSelector","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call","matchesList","ownerDocument","querySelectorAll","i","item","setComponentEnabled","destroy","removeEventListener","clear"],"sourceRoot":""}